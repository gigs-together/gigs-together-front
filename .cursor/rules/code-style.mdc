---
description: "Code style & typing rules (TypeScript/NestJS)"
globs:
  - "**/*.ts"
  - "**/*.tsx"
---

## Code style (project-wide)

- **Prefer explicit, strict typing**: keep types narrow, avoid widening to `string | number | ...` when the domain is known.
- **Comments must be in English (Latin alphabet) only**: do not write comments in Cyrillic.
- **Boolean naming**: boolean variables (and flags) should preferably start with `is` (e.g. `isActive`, `isAdmin`, `isValid`).
- **No builds/tests/dev servers without explicit request**:
  - Do not run `build`, `test`, `lint`, `typecheck`, `dev`, or start watchers/servers unless the user explicitly asks.
  - If execution is needed to validate a change, ask first instead of running it proactively.
- **`any` is forbidden by default**:
  - Use `unknown` + type guards / narrowing instead of `any`.
  - If you need a flexible object shape, prefer `Record<string, unknown>` (or a specific interface) over `any`.
  - If you need to type JSON, prefer `unknown` (or a `JsonValue` union) over `any`.
  - `any` is allowed only when:
    - There is no realistic alternative (e.g., truly untyped 3rd‑party API surface)
  - When using `any`, **localize it** (cast at the boundary, not across the codebase) and add a short comment explaining why.
- **Type assertions (`as`) — avoid as much as possible**:
  - Prefer type guards, narrowing, and better source types instead of `as`.
  - Prefer `satisfies` for validating object shapes without changing inferred types.
  - Prefer parsing/validation at boundaries (HTTP, env, 3rd‑party SDKs) so the rest of the code stays strongly typed.
  - Avoid `as any` entirely; allow only as a last resort with a short comment explaining why it’s unavoidable.
- **React typing style**:
  - Do not use `React.*` namespace types like `React.RefObject<T>`.
  - Import types directly: `import type { RefObject } from 'react'` and use `RefObject<T>`.
  - **Type imports must be separate**: do not mix value and type imports in one statement (avoid `import { foo, type Bar } from '...'`).
    - Use `import { foo } from '...'` and `import type { Bar } from '...'`.
- **Prefer `readonly` for immutability** where applicable (DTOs, config objects, constants).
- **Prefer named types** (`type`/`interface`) for public APIs (service methods, controller responses, module exports).
  - **No inline object types** in public signatures: do not write `Promise<{ ... }>` or `foo(arg: { ... })`.
  - Always extract the object shape into a named `interface`/`type` (ideally colocated in `types/requests/*` for DTOs).
- **Strictness over best-effort fallbacks (applies to all code)**:
  - Do not add "just in case" logic that guesses shapes or silently recovers from unexpected states.
  - If something is not as expected, **throw an error** (or return an explicit error result) instead of defaulting.
  - Avoid patterns that hide invalid states, e.g. `res?.data ?? res ?? {}`, `value || {}`, `arr ?? []` when the default is not explicitly part of the contract.
  - At boundaries (HTTP, env, storage, 3rd‑party SDKs) parse as `unknown`, validate the expected shape, and **throw** if it doesn't match.
- **Prefer `interface` over `type`** for object shapes, unless it’s impossible or significantly more complex:
  - Use **`interface`** for DTOs, public contracts, and extendable object shapes.
  - Use **`type`** when you need unions/intersections, mapped/conditional types, tuples, or other patterns that `interface` can’t express cleanly.
- **NestJS patterns**:
  - Prefer DTOs for request/response shapes.
  - Keep controller thin, move logic to services.
  - Use dependency injection consistently; avoid creating clients directly in methods unless scoped and justified.

